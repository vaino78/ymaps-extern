var fs = require('fs');

var data = JSON.parse(fs.readFileSync('data.json', 'utf8'));

var NS = 'ymaps';
var NS_PREFIX = NS + '.';

var ret = '';
ret += [
  '',
  '/**',
  ' * @fileoverview Autogenerated extern for Yandex maps v2.1.',
  ' * @externs',
  ' */',
  'var ' + NS + ' = {};', '', ''
].join("\n");

var rendered = {};

var names = [];
data.forEach(function(item) {
  names.push(item.name);
});
names.sort(function(a, b) {
  return b.length - a.length;
});

var namesRegex = new RegExp('(' +names.join("|").replace(/\./g, '\\.') + ')', 'g');

/**
 * Объект, хранящий данные сигнатур свойств и методов интерфейсов (с учетом 
 * наследования интерфейсов) для дополнения сигнатур классов, реализующих 
 * данные интерфейсы
 * 
 * @type {Object}
 */
var interf = {};
data.forEach(function(item) {
  if(isInterface(item.name)) {
    interf[ item.name ] = JSON.parse(JSON.stringify(item.def || {})); // clone...
  }
});

Object.keys(interf).forEach(function(i) {
  var inherits = [];
  inheritsPad(i, inherits);
  
  if(!inherits.length) {
    return;
  }
  
  var props = {},
    methods = {};
    
  if(interf[i].methods) {
    interf[i].methods.forEach(function(m) {
      methods[m] = 1;
    });
  }
  
  if(interf[i].props) {
    interf[i].props.forEach(function(p) {
      props[p] = 1;
    });
  }
  
  inherits.forEach(function(inh) {
    if(interf[inh].methods) {
      interf[inh].methods.forEach(function(m) {
        if(!methods[m.name]) {
          var mm = JSON.parse(JSON.stringify(m));
          if(!mm['inheritsFrom']) {
            mm['inheritsFrom'] = inh;
          }
          if(typeof(interf[i].methods) === 'undefined') {
            interf[i].methods = [];
          }
          interf[i].methods.push(mm);
          methods[mm.name] = 1;
        }
      });
    }
    if(interf[inh].props) {
      interf[inh].props.forEach(function(p) {
        if(!props[p.name]) {
          var pp = JSON.parse(JSON.stringify(p));
          if(!pp['inheritsFrom']) {
            pp['inheritsFrom'] = inh;
          }
          if(typeof(interf[i].props) === 'undefined') {
            interf[i].props = [];
          }
          interf[i].props.push(pp);
          props[pp.name] = 1;
        }
      });
    }
  });
});

//console.error(JSON.stringify(interf, null, 2));
//process.exit(1);

data.forEach(function(item) {
  var r = [];


  // CTOR
  var ctorParamsList = [];
  r.push('/**');
  if ((item.def.ctorParams || item.def.params) && !rendered['__ctor__' + item.name]) {
    (item.def.ctorParams || item.def.params).forEach(function(p) {
      ctorParamsList.push(p.param);
      r.push(' * @param {' + normilizeType(p.type, p.isRequired) + '} ' + p.param + ' ' + p.description);
    });
    rendered['__ctor__' + item.name] = true;
  }
  if (item.def.hasCtor) {
    if (isInterface(item.name)) {
      r.push(' * @interface');
    } else {
      r.push(' * @constructor');
    }
  }
  if (item.def.inherits) {
    item.def.inherits.forEach(function(parentName) {
      if (isInterface(parentName)) {
        r.push(' * @implements {' + NS_PREFIX + parentName + '}');
      } else {
        r.push(' * @extends {' + NS_PREFIX + parentName + '}');
      }
    });
  }
  r.push(' */');
  r.push(NS_PREFIX + item.name + ' = function(' + ctorParamsList.join(', ') + ') {};');
  r.push('', '');

  // METHODS
  if (item.def.methods) {
    item.def.methods.forEach(function(p) {
      if (rendered['__param__' + item.name + '.' + p.name]) {
        return;
      }
      rendered['__param__' + item.name + '.' + p.name] = true;

      var paramsList = [];
      r.push('/**');
      if (p.description) {
        r.push(' * ' + p.description);
      }
      if (p.params) {
        p.params.forEach(function(p) {
          paramsList.push(p.param);
          r.push(' * @param {' + normilizeType(p.type, p.isRequired) + '} ' + p.param + ' ' + p.description);
        });
      }
      if (p['return']) {
        r.push(' * @return {' + normilizeType(p['return'], true) + '}');
      }
      r.push(' */');
      if (r.length == 2) {
        r = [];
      }
      r.push(NS_PREFIX + item.name + '.prototype.' + p.name + ' = function(' + paramsList.join(', ') + ') {};');
      r.push('', '');
    });
  }
  // PROPERTIES
  if (item.def.props) {
    item.def.props.forEach(function(p) {
      if (rendered['__prop__' + item.name + '.' + p.name]) {
        return;
      }
      rendered['__prop__' + item.name + '.' + p.name] = true;

      var paramsList = [];
      r.push('/**');
      if (p.description) {
        r.push(' * ' + p.description);
      }
      if (p.type) {
        r.push(' * @type {' + normilizeType(p.type, true) + '}');
      }
      r.push(' */');
      if (r.length == 2) {
        r = [];
      }
      r.push(NS_PREFIX + item.name + '.prototype.' + p.name + ';');
      r.push('', '');
    });
  }

  ret += r.join("\n");
});

if (fs.existsSync("extern.ymaps.js")) {
  fs.unlinkSync("extern.ymaps.js");
}

fs.writeFile("extern.ymaps.js", ret, function(err) {
    if(err) {
        console.log(err);
    } else {
        console.log("The file was saved!");
    }
});

function normilizeType(str, isRequired) {
  str = str.replace(namesRegex, NS_PREFIX + "$1").replace(/Integer/g, "number");

  var type = str.split('|');
  for (var i = 0, l = type.length; i < l; i++) {
    while ((/\[\]$/).test(type[i])) {
      type[i] = 'Array.<' + type[i].replace(/\[\]((\[\])*)$/, '>$1');
    }
  }

  return (type.join('|') || '*') + (isRequired ? '' : '=');
};

function isInterface(str) {
  return str.length > 1 && str[0] == 'I' && str[1] == str[1].toUpperCase();
};

/**
 * @param {string} interfaceName
 * @param {Array.<string>} padInto
 */
function inheritsPad(interfaceName, padInto) {
  if(interf[interfaceName] && interf[interfaceName].inherits) {
    interf[interfaceName].inherits.forEach(function(inh) {
      padInto.push(inh);
      inheritsPad(inh, padInto);
    });
  }
};